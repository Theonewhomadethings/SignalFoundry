# prompt.txt — Rust Market Data Viewer (Databento + CME) — Web + Optional Desktop

## Goal
Build an MVP **Market Data Viewer** that retrieves **historical** and **live** market data using **Databento’s official Rust client** and displays it in a simple UI (web app). Optionally package the same UI as a desktop app via **Tauri**.

The app should support:
- **Historical** queries (trades or OHLCV bars) over a time range
- **Live** streaming updates (trades or bars) via WebSocket
- A minimal but clean UI to pick symbols + schema and visualize results

This is a “vibe-codeable” project: clean architecture, minimal complexity, real working data flow.

---

## Non-goals (for MVP)
- No authentication system for end-users (beyond holding Databento API key server-side)
- No advanced order book visualization (L2/L3) initially
- No persistent database (in-memory is fine)
- No backtesting engine (but leave hooks for record/replay)

---

## Tech Stack
### Backend (Rust)
- Rust 2021 edition
- `tokio` async runtime
- `axum` for HTTP + WebSockets
- `tower-http` for CORS
- `serde` + `serde_json` for JSON types
- `tracing` + `tracing-subscriber` for logging
- Databento official Rust crate: `databento` (use current compatible version)

### Frontend (Web)
- React + Vite + TypeScript
- Charting: `lightweight-charts` (candles + line) or equivalent
- UI: minimal CSS/Tailwind optional (keep simple)

### Optional Desktop Packaging
- Tauri wrapping the same Vite UI and bundling the Rust backend (or proxying to it)

---

## High-Level Architecture
- **Backend** holds the Databento API key (read from `DATABENTO_API_KEY` env var)
- **Frontend** never sees the API key; it only talks to backend endpoints
- Historical data: frontend calls REST endpoint → backend calls Databento Historical API → returns JSON
- Live data: frontend opens WS → backend connects to Databento Live stream → forwards messages to WS clients

**Important data notes**
- Databento prices may be fixed-point integers (commonly 1e-9 units). Keep raw int in backend output; frontend can format to float.
- Use Databento symbol mapping (`PitSymbolMap` / metadata symbol map) to show human-readable symbols.

---

## Project Structure (Monorepo / Workspace)
Create a Rust workspace plus UI folder:
market-viz-rs/
Cargo.toml # workspace
crates/
shared/
Cargo.toml
src/lib.rs # shared request/response types
backend/
Cargo.toml
src/main.rs # axum server, REST + WS, Databento clients
src/databento_service.rs # (optional) isolate Databento code behind a service trait
src/error.rs # (optional) error types
ui/
package.json
vite.config.ts
src/
main.tsx
App.tsx
api.ts # fetch helpers
components/
SymbolForm.tsx
HistoricalChart.tsx
TradeTape.tsx
LiveStream.tsx
README.md


---

## Backend Requirements

### Config
- `DATABENTO_API_KEY` must be read from environment.
- Provide friendly startup error if missing.
- Default dataset: `GLBX.MDP3` (CME). Keep dataset configurable in code (easy to extend later).

### REST Endpoints
1) `GET /api/health`
- Returns `"ok"` for sanity check

2) `POST /api/historical`
- Request JSON (shared type):
  ```json
  {
    "symbols": ["ES.FUT"],
    "schema": "trades",
    "stype_in": "parent",
    "start_rfc3339": "2022-06-10T14:30:00Z",
    "end_rfc3339": "2022-06-10T14:40:00Z",
    "limit": 1000
  }
Supported schema values for MVP:

"trades"

"ohlcv-1s"

"ohlcv-1m"

Response JSON:

For trades:

json
Copy code
{ "schema": "trades", "data": [ { "ts_event_unix_ns": 0, "symbol": "ES.FUT", "price_i64": 0, "size_u32": 1 } ] }
For OHLCV:

json
Copy code
{ "schema": "ohlcv-1s", "data": [ { "ts_event_unix_ns": 0, "symbol": "ES.FUT", "open_i64": 0, "high_i64": 0, "low_i64": 0, "close_i64": 0, "volume_u64": 0 } ] }
Error behavior:

Invalid schema → 400

Invalid RFC3339 time → 400

Databento error → 502 with message

Missing API key → 401

WebSocket Endpoint
GET /ws/live

MVP: can hardcode subscription to ES.FUT + trades.

Better (still easy): allow query params:

/ws/live?symbols=ES.FUT,CL.FUT&schema=trades&stype_in=parent

On connect, backend subscribes to Databento Live stream and forwards messages as JSON.

Message format:

json
Copy code
{
  "type": "trade",
  "ts_event_unix_ns": 123,
  "symbol": "ES.FUT",
  "price_i64": 123,
  "size_u32": 5
}
Cross-cutting Backend Requirements
Enable CORS for local dev (frontend on Vite port)

Use tracing logs for requests + stream events

Avoid blocking operations on tokio runtime

Clean separation between HTTP handlers and Databento client logic (service module is ideal)

Frontend Requirements (UI MVP)
Pages / Layout
Single page app with:

Header: “Market Data Viewer (Databento)”

Controls panel:

Symbols input (comma-separated): default ES.FUT

Schema dropdown: trades / ohlcv-1s / ohlcv-1m

Start time + end time (RFC3339 or datetime picker converted to RFC3339)

Buttons:

“Fetch Historical”

“Connect Live”

“Disconnect”

Display area:

If schema == trades: table (“trade tape”) showing latest N trades

If schema == OHLCV: candlestick or line chart

API Integration
POST /api/historical to fetch and render historical results

WebSocket /ws/live to render real-time updates:

Append trades to trade tape

For bars: update current candle

Formatting
Convert price_i64 to a human display:

displayPrice = price_i64 / 1e9 (as float) OR show integer with note “fixed-point 1e-9”

Convert ts_event_unix_ns to readable timestamp

UX expectations
Show loading state and error message area

Keep it minimal but not janky

Implementation Plan (Milestones)
Milestone 1 — Workspace + Types
Create Rust workspace and shared crate with request/response types

Add basic README with run instructions

Milestone 2 — Backend REST
Implement /api/health

Implement /api/historical for trades + OHLCV (1s, 1m)

Ensure errors return correct codes/messages

Verify with curl

Milestone 3 — Backend Live WS
Implement /ws/live with at least hardcoded subscription

Forward live trades to WS clients as JSON

Add symbol mapping so symbols are readable

Milestone 4 — Frontend
Vite React UI with form + historical fetch + rendering

WebSocket connect/disconnect + live view

Milestone 5 — Polish
Better query param subscriptions for WS

Add basic tests

Improve README and developer experience

Optional Milestone 6 — Tauri Desktop
Wrap UI with Tauri

Provide a simple script to run backend + UI

Testing Requirements
Backend:

Unit tests for parsing:

schema parsing

RFC3339 parsing error handling

Integration-ish tests can be lightweight (mock service layer):

You may abstract Databento calls behind a trait (e.g. MarketDataService) and provide a fake implementation for tests.

Frontend:

Minimal: manual testing is acceptable for MVP

Optional: basic component tests for rendering states

Developer Experience / Commands
Provide the following scripts/instructions in README:

Backend
bash
Copy code
export DATABENTO_API_KEY="..."
cargo run -p backend
Frontend
bash
Copy code
cd ui
npm install
npm run dev
Optional root-level helper:

justfile or makefile to run both

Security / Operational Notes
Never expose Databento API key to the frontend

Avoid logging secrets

Consider basic rate limiting later (nice-to-have)

Keep CORS permissive only for local dev (document it)

Acceptance Criteria (Definition of Done)
MVP is done when:

GET /api/health returns "ok"

POST /api/historical returns valid JSON for:

schema=trades

schema=ohlcv-1s

schema=ohlcv-1m

GET /ws/live streams JSON trade events to the browser in real time

React UI can:

Fetch historical data and render it (table or chart)

Connect to live stream and display updates

Setup is documented in README (including env var)

Nice-to-have Extensions (Post-MVP)
Dataset picker (other exchanges / venues)

Instrument reference panel (contract size, expiry, etc.)

Record & replay:

Stream live DBN to file

Replay from file for deterministic debugging

L2/L3 order book viewer

Caching layer for historical queries

Guidance for Claude Code
Please implement the project end-to-end.

Start with the backend workspace setup, then add the UI.

Keep code clean and modular.

Prefer correctness and debuggability over overly clever abstractions.

Provide clear README instructions and sensible defaults.

If Databento API details require small adjustments (crate types / method names), make the code compile with the currently available Databento crate and adapt accordingly.

Deliverables:

Full repository scaffold with all files

Working backend + working UI

README.md with run instructions

Optional: Tauri packaging instructions if time allows
